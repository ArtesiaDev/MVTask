# MVx_Implementation
![MVx](https://github.com/user-attachments/assets/4e383ab3-69a0-45ca-902a-7e907f39684c)


Собственная реализация MVC, MVP и MVVM паттернов в контексте стандарнтных Unity UI элементов.

В проекте Присутствует 4 основных сцены и папки:

-MVC

-MVP

-MVVM - реализация на основе обычных C# событий.

-MVVM_React - реализация на основе реактивной библиотеки R3.

### Особенности реализации
Для каждого из MV* существует много разных реализаций и трактовок. Для воссоздания данной реализации я опирался на исторические причины возникновения каждого из паттернов - решение проблем, связанных с невозможностью укладывать новые тенденции развития графического дизайна в старые паттерны проектирования.

MVC (Model-View-Controller) - 1979г - позволяет разделять программную логику на 3 слабо связанные части: Model, View, Controller, что упрощает тестирование и поддержку кода.

MVP (Model-View-Presentor) - в начале 1990-х - с появлением сенсорных экранов, появляются новые графические элементы, которые невозможно отнести либо ко View, либо к Controller, так как они принимают Input и отвечают за отображение одновременно (Button, InputField, Toggle, ProgressBar). Решение - ответственность за Input лежит не только на Controller, который теперь именуют Presentor, но и на View. Model становится сложнее (слоистее) и позволяет хранить данные, которые связаны не только с Бизнес логикой, но и состояниями View.

MVVM (Model-View-ViewModel) - 2005г - пользовательский интерфейс теперь может содержать разные режимы отображения, многократно увеличился объем данных, связанных с состояниями View. Появляются WPF и подобные ей платформы, которые используют "Событийную модель", для работы с которой необходимо "реактивное" общение между слоями программы. Решение - данные и состояния View теперь хранятся не в Model, а в Presentor, который переименовали во ViewModel. При изменении свойств View или ViewModel происходит реактивное обновление компонентов, которые эти свойства отслеживают.
